## item14:如果函数不抛出异常请使用noexcept

[item14原文](https://cntransgroup.github.io/EffectiveModernCppChinese/3.MovingToModernCpp/item14.html)

[参考视频](https://www.bilibili.com/video/BV1PS4y1H73n/?spm_id_from=333.337.search-card.all.click)

### 异常处理
抛出异常：throw 异常;作用是让调用者看到code产生了异常，如果调用者无异常处理手段，那么让调用者的调用者看到，以此类推。

接住异常：
```C++
try{
    //可能抛出异常的code
} catch(/*异常类型，通常为const &*/){
    //异常处理方式
}
```

如果异常类型不确定的话可以使用catch(...){处理方式}，可以接任意异常，并且在catch中仍可以使用throw，继续抛，并且父类异常引用可以接子类异常。

使用noexcept可以保证函数不抛出异常。
```C++
void func(int a) noexcept{
    ...
}
```

![标准异常库](https://i-blog.csdnimg.cn/blog_migrate/0964610a3de15efc2e3ba3de5b19c8d9.png)

### item15
关于一个函数是否已经声明为noexcept是接口设计的事。就其本身而言，函数是否为noexcept和成员函数是否const一样重要。这个可以影响到调用代码的异常安全性（exception safety）和效率。当你知道这个函数不会抛异常而没加上noexcept，那这个接口说明就有点差劲了。

为保证不会抛出异常的函数声明noexcept可以允许编译器生成更好的代码。要想知道为什么，了解C++98和C++11指明一个函数不抛异常的方式是很有用了。考虑一个函数f，它保证调用者永远不会收到一个异常。两种表达方式如下：
```C++
int f(int x) throw();   //C++98风格，没有来自f的异常
int f(int x) noexcept;  //C++11风格，没有来自f的异常
```

在C++98的异常说明中，调用栈（the call stack）会展开至f的调用者，在一些与这地方不相关的动作后，程序被终止。C++11异常说明的运行时行为有些不同：调用栈只是可能在程序终止前展开。

在C++98中，异常处理的过程是较为严格的。具体来说，当异常被抛出时，程序会根据异常的类型向上查找并执行相应的异常处理机制（即捕获该异常的catch块）。在此过程中，调用栈会被展开（unwinding），这意味着：

* 程序从异常抛出的位置开始，逐一返回到每个函数的调用者，执行这些函数的析构函数来清理资源。
* 如果某个函数的异常被捕获并处理，栈会展开回到抛出异常的函数的调用者，执行适当的清理工作。
这个过程是同步的：调用栈会完全展开，直到程序最终终止或者找到一个捕获该异常的catch块。

C++11引入了一些变化，使得异常处理的行为变得更加灵活。在C++11中，异常说明的运行时行为有所不同：

* 在C++11中，调用栈的展开不一定是完全同步的。也就是说，调用栈可能会在程序终止之前展开，但这并不是强制要求。
* 这种“可能性”意味着，在某些情况下，栈展开的过程可能会被延迟，甚至在异常被抛出之后的某些不相关的动作中可能出现一些不确定性或“跳过”的行为。


在一个noexcept函数中，当异常可能传播到函数外时，优化器不需要保证运行时栈（the runtime stack）处于可展开状态；也不需要保证当异常离开noexcept函数时，noexcept函数中的对象按照构造的反序析构。

```C++
RetType function(params) noexcept;  //极尽所能优化
RetType function(params) throw();   //较少优化
RetType function(params);           //较少优化
```

#### 异常安全保证

假如你有一份C++98代码，里面用到了std::vector<Widget>。Widget通过push_back一次又一次的添加进std::vector：
```C++
std::vector<Widget> vw;
…
Widget w;
…                   //用w做点事
vw.push_back(w);    //把w添加进vw
…
```

当新元素添加到std::vector，std::vector可能没地方放它，换句话说，std::vector的大小（size）等于它的容量（capacity）。这时候，std::vector会分配一个新的更大块的内存用于存放其中元素，然后将元素从老内存区移动到新内存区，然后析构老内存区里的对象。在C++98中，移动是通过复制老内存区的每一个元素到新内存区完成的，然后老内存区的每个元素发生析构。这种方法使得push_back可以提供很强的异常安全保证：如果在复制元素期间抛出异常，std::vector状态保持不变，因为老内存元素析构必须建立在它们已经成功复制到新内存的前提下。**强异常安全**

但是如果将上述代码用C++11提供的移动改写，那么代码就不具备异常安全。如果n个元素已经从老内存移动到了新内存区，但异常在移动第n+1个元素时抛出，那么push_back操作就不能完成。但是原始的std::vector已经被修改：有n个元素已经移动走了。恢复std::vector至原始状态也不太可能，因为从新内存移动到老内存本身又可能引发异常。

这是个很严重的问题，因为老代码可能依赖于push_back提供的强烈的异常安全保证。因此，C++11版本的实现不能简单的将push_back里面的复制操作替换为移动操作，除非知晓移动操作绝不抛异常，这时复制替换为移动就是安全的，唯一的副作用就是性能得到提升。

因此在库中为了确保函数的异常安全保证，我们按“如果可以就移动，如果必要则复制”的策略，那么我们只有在移动操作保证不抛出异常的情况下才敢使用移动，否则使用拷贝。那么我们在声明移动相关函数的时候需要添加noexcept声明，并且需要保证函数不抛出异常。


swap函数是noexcept的另一个绝佳用地。swap是STL算法实现的一个关键组件，它也常用于拷贝运算符重载中。它的广泛使用意味着对其施加不抛异常的优化是非常有价值的。

比如，数组和std::pair的swap声明如下：
```C++
template <class T, size_t N>
void swap(T (&a)[N],
          T (&b)[N]) noexcept(noexcept(swap(*a, *b)));  //见下文

template <class T1, class T2>
struct pair {
    …
    void swap(pair& p) noexcept(noexcept(swap(first, p.first)) &&
                                noexcept(swap(second, p.second)));
    …
};
```

这些函数视情况noexcept：它们是否noexcept依赖于noexcept声明中的表达式是否noexcept。假设有两个Widget数组，交换数组操作为noexcept的前提是数组中的元素交换是noexcept的，即Widget的swap是noexcept。因此Widget的swap的作者决定了交换widget的数组是否noexcept。对于Widget的交换是否noexcept决定了对于Widget数组的交换是否noexcept，以及其他交换，比如Widget的数组的数组的交换是否noexcept。

如果你声明一个函数为noexcept，但随即又后悔了，你没有选择。你可以从函数声明中移除noexcept（即改变它的接口），这理所当然会影响客户端代码。你可以改变实现使得这个异常可以避免，再保留原版本（现在来看不正确的）异常说明。如果你这么做，在异常试图离开这个函数时程序将会终止。或者你就顺从了既有实现，舍弃了激起你兴趣的东西，从一开始就改变实现。这些选择都不尽人意。

这个问题的本质是实际上大多数函数都是异常中立（exception-neutral）的。这些函数自己不抛异常，但是它们内部的调用可能抛出。此时，异常中立函数允许那些抛出异常的函数在调用链上更进一步直到遇到异常处理程序，而不是就地终止。

如果一个简单的函数实现可能引发异常（比如调用一个可能抛异常的函数），而你为了讨好调用者隐藏了这个（比如捕获所有异常，然后替换为状态码或者特殊返回值），这不仅会使你的函数实现变得复杂，还会让调用点的代码变得复杂。调用者可能不得不检查状态码或特殊返回值。而这些复杂的运行时开销（比如额外的分支，大的函数给指令缓存带来的压力等）可能超出noexcept带来的性能提升，再加上你会悲哀的发现这些代码又难读又难维护。那是糟糕的软件工程化。

默认情况下，内存释放函数和析构函数——不管是用户定义的还是编译器生成的——都是隐式noexcept。因此它们不需要声明noexcept。（这么做也不会有问题，只是不合常规）。

**宽泛契约（wild contracts）和严格契约（narrow contracts）的函数。**

有宽泛契约的函数没有前置条件。这种函数不管程序状态如何都能调用，它对调用者传来的实参不设约束。（“不管程序状态如何”和“不设约束”对已经行为未定义的程序无效。比如std::vector::size有宽泛契约，但是并不保证如果你把一块随机内存转换为一个std::vector，在这块内存上调用它会有合理的表现。转换的结果是未定义的，所以包含这个转换的程序也无法保证表现合理）宽泛契约的函数决不表现出未定义行为。

反之，没有宽泛契约的函数就有严格契约。对于这些函数，如果违反前置条件，结果将会是未定义的。

如果你写了一个有宽泛契约的函数并且你知道它不会抛异常，那么遵循这个条款给它声明一个noexcept是很容易的。对于严格契约的函数，情况就有点微妙了。举个例子，假如你在写一个形参为std::string的函数f，并且假定这个函数f很自然的决不引发异常。这就表明f应该被声明为noexcept。

在假如f有一个前置条件：类型为std::string的参数的长度不能超过32个字符。如果现在调用f并传给它一个大于32字符的std::string，函数行为将是未定义的，因为根据定义违反了前置条件，导致了未定义行为。f没有义务去检查前置条件，它假设这些前置条件都是满足的。（调用者有责任确保参数字符不超过32字符等这些假设有效。）即使有前置条件，将f声明为noexcept似乎也是合适的：
```C++
void f(const std::string& s) noexcept;  //前置条件：
                                        //s.length() <= 32 
```

假定f的实现者在函数里面检查前置条件冲突。虽然检查是没有必要的，但是也没禁止这么做，检查前置条件可能也是有用的，比如在系统测试时。debug一个抛出的异常一般都比跟踪未定义行为起因更容易。那么怎么报告前置条件冲突使得测试工具或客户端错误处理程序能检测到它呢？简单直接的做法是抛出“precondition was violated”异常，但是如果f声明了noexcept，这就行不通了；抛出一个异常会导致程序终止。因为这个原因，区分严格/宽泛契约库设计者一般会将noexcept留给宽泛契约函数。

**请记住：**
* noexcept是函数接口的一部分，这意味着调用者可能会依赖它
* noexcept函数较之于non-noexcept函数更容易优化
* noexcept对于移动语义，swap，内存释放函数和析构函数非常有用
* 大多数函数是异常中立的（译注：可能抛也可能不抛异常）而不是noexcept
