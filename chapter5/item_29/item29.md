## item29:假定移动操作不存在，成本高，未被使用

[item29原文](https://cntransgroup.github.io/EffectiveModernCppChinese/5.RRefMovSemPerfForw/item29.html)

C++11倾向于为缺少移动操作的类生成它们，但是只有在没有声明复制操作，移动操作，或析构函数的类中才会生成移动操作。数据成员或者某类型的基类禁止移动操作（比如通过delete移动操作），编译器不生成移动操作的支持。

所有C++11的标准库容器都支持了移动操作，但是认为移动所有容器的开销都非常小是个错误。对于某些容器来说，压根就不存在开销小的方式来移动它所包含的内容。对另一些容器来说，容器的开销真正小的移动操作会有些容器元素不能满足的注意条件。

考虑一下std::array，这是C++11中的新容器。std::array本质上是具有STL接口的内置数组。这与其他标准容器将内容存储在堆内存不同。存储具体数据在堆内存的容器，本身只保存了指向堆内存中容器内容的指针。这个指针的存在使得在常数时间移动整个容器成为可能，只需要从源容器拷贝保存指向容器内容的指针到目标容器，然后将源指针置为空指针就可以了：
```C++
std::vector<Widget> vw1;

//把数据存进vw1
…

//把vw1移动到vw2。以常数时间运行。只有vw1和vw2中的指针被改变
auto vw2 = std::move(vw1);
```
![图解](https://cntransgroup.github.io/EffectiveModernCppChinese/5.RRefMovSemPerfForw/media/item29_fig1.png)

std::array没有这种指针实现，数据就保存在std::array对象中：
```C++
std::array<Widget, 10000> aw1;

//把数据存进aw1
…

//把aw1移动到aw2。以线性时间运行。aw1中所有元素被移动到aw2
auto aw2 = std::move(aw1);
```

![图解](https://cntransgroup.github.io/EffectiveModernCppChinese/5.RRefMovSemPerfForw/media/item29_fig2.png)

注意aw1中的元素被移动到了aw2中。假定Widget类的移动操作比复制操作快，移动Widget的std::array就比复制要快。所以std::array确实支持移动操作。但是使用std::array的移动操作还是复制操作都将花费线性时间的开销，因为每个容器中的元素终归需要拷贝或移动一次。

另一方面，std::string提供了常数时间的移动操作和线性时间的复制操作。这听起来移动比复制快多了，但是可能不一定。许多字符串的实现采用了小字符串优化（small string optimization，SSO）。“小”字符串（比如长度小于15个字符的）存储在了std::string的缓冲区中，并没有存储在堆内存，移动这种存储的字符串并不比复制操作更快，使用内存缓冲区存储而不分配堆内存空间，是为了更好的效率。然而这种内存管理的效率导致移动的效率并不比复制操作高。

因此，存在几种情况，C++11的移动语义并无优势：
* 没有移动操作：要移动的对象没有提供移动操作，所以移动的写法也会变成复制操作。
* 移动不会更快：要移动的对象提供的移动操作并不比复制速度更快。
* 移动不可用：进行移动的上下文要求移动操作不会抛出异常，但是该操作没有被声明为noexcept。（异常安全）

**请记住：**
* 假定移动操作不存在，成本高，未被使用。
* 在已知的类型或者支持移动语义的代码中，就不需要上面的假设。
